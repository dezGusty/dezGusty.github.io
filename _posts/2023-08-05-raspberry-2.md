---
layout: post
title: Raspberry PI - 2 ğŸ’
---

Ãnceputurile cu Raspberry PI 4 sunt relativ uÈ™oare. Este Linux, deci se gÄƒsesc o mulÈ›ime de tutoriale pe net. Fix de Ã®ncÄƒ unul este nevoie.
[Raspberry PI Imager](https://www.raspberrypi.com/software/) poate fi folosit pentru crearea unui SD card sau SSD cu un sistem de operare bazat pe Linux, numai bun de pus pe Raspberry PI 4.

Cel mai important: de activat SSH È™i setat accesul (de exemplu prin user/parolÄƒ)
![setup SSH]({{ site.baseurl }}/images/2023.08.06.pi4.setup.png)

Se conecteazÄƒ SSD-ul scris la Raspberry PI, se pune undeva unde va fi uitat (dar are acces la WiFI sau cablu LAN) È™i se porneÈ™te.

## SÄƒ vÄƒd cÄƒ merge

Bine, bine, nu e nevoie sÄƒ mÄƒ conectez la Raspberry PI È™i sÄƒ vÄƒd UI-ul ca sÄƒ È™tiu cÄƒ e pornit È™i merge.
Dar parcÄƒ nu pare la fel dacÄƒ merge doar din SSH.

(A more complete instruction set for accessing the remote desktop of PI: <https://iotdesignpro.com/projects/setup-raspberry-pi-remote-desktop-using-tightvnc>)

Primul lucru dupÄƒ boot, conectare cu SSH de pe alt computer pe Raspberry PI.

```sh
ssh PIHOSTNAME -l PIUSER
```

Apoi actualizare de pachete È™i instalarea unui server VNC

```sh
sudo apt-get update
sudo apt-get upgrade 
sudo apt-get install tightvncserver
```

Configurarea serverului de pe Raspberry PI

```sh
vncserver
```

> + setare parolÄƒ

Pe computerul principal, o instalare de TightVNC, È™i apoi conectarea cu `TightVNC Viewer` la PIHOSTNAME:5901

## Un website simplu, cu server

### Cheie SSH pentru git

Git ar trebui sÄƒ fie preinstalat. La fel È™i utilitarul ssh-keygen.
Cu execuÈ›ia lui, pot sÄƒ-mi creez o cheie de SSH pe care sÄƒ o pun È™i pe contul personal de github È™i sÄƒ mÄƒ identific faÈ›Äƒ de server.

```sh
ssh-keygen
```

Dar trebuie sÄƒ o uploadez Ã®n contul personal.
Fie pornesc un browser È™i fac un login Ã®n conexiunea de VNC.
Fie Ã®mi aduc cheia local

```sh
scp PIUSER@PIHOSTNAME:/home/PIUSER/.ssh/id_rsa.pub c:/temp/gheo/id_rsa
```

FiÈ™ierul local Ã®l pot deschide ulterior (de pe computerul principal) È™i copia apoi cheia Ã®n [cheile de profil pentru github](https://github.com/settings/keys)

### Mediul de lucru

Hai sÄƒ facem un site cu rust, cÄƒ e simplu È™i e la modÄƒ.
Rust se instaleazÄƒ facil cu instrucÈ›iunile oficiale

```sh
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

âš ï¸ NecesitÄƒ È™i o reconectare la sesiunea de SSH.

### Primul web server

Un web server simplu cu pagini statice. FÄƒcut dupÄƒ niÈ™te tutoriale.

```sh
cd ~/work/
git clone <git@github.com>:dezGusty/gse.git
cd gse
cargo build --release
```

#### Test 1 (OpÈ›ional)

De probÄƒ, un cargo run pentru a vedea.

```sh
cargo run
```

> CTRL + C pentru a opri aplicaÈ›ia

Ok, ce se vede? Unde ?
PÄƒi hai sÄƒ ne conectÄƒm la VNC (de repornit serverul vnc dacÄƒ e nevoie)

```sh
vncserver
```

È˜i Ã®ntr-un browser pornit din Raspberry PI via VNC, ar trebui sÄƒ meargÄƒ apelat serverul web (<http://127.0.0.1:14240>)
AplicaÈ›ia gse ar trebui sÄƒ fie configuratÄƒ sÄƒ ruleze pe portul 14240 din oficiu.

#### Sub-config 1 (OpÈ›ional)

DacÄƒ e ceva ce se actualizeazÄƒ mai des, cÃ¢t este activ web server-ul, nu va merge recompilat codul.
Pentru a permite È™i scenariul Äƒsta, ar fi bine sÄƒ existe un director dedicat deploy-ului, de unde sÄƒ se execute binarele.

```sh
mkdir /home/PIUSER/work/deploy
mkdir /home/PIUSER/work/deploy/gse
cp -r /home/PIUSER/work/gse/target/release/* /home/PIUSER/work/deploy/gse/
```

### Primul web server, ca serviciu

Bazat pe exemplul de aici: <https://www.shellhacks.com/systemd-service-file-example/>

```sh
sudo touch /etc/systemd/system/gse-web.service
sudo chmod 664 /etc/systemd/system/gse-web.service
sudo nano /etc/systemd/system/gse-web.service
```

De setat conÈ›inutul configurÄƒrii serviciului (presupun existenÈ›a directorului *deploy*)

```ini
[Unit]
Description=Exemplu gse web service
After=network.target

[Service]
Type=simple
User=PIUSER
ExecStart=/home/PIUSER/work/deploy/gse/gse
Restart=always
RestartSec=2
TimeoutStartSec=0
WorkingDirectory=/home/PIUSER/work/gse

[Install]
WantedBy=multi-user.target
```

Se reÃ®ncarcÄƒ lista de servicii/daemons.
Se activeazÄƒ serviciul pentru a porni odatÄƒ cu Raspberry-ul.

```sh
sudo systemctl daemon-reload
sudo systemctl enable gse-web
sudo systemctl start gse-web
```

Se poate verifica starea serviciului cu

```sh
systemctl status gse-web
```

DacÄƒ este nevoie de modificÄƒri se poate reporni cu.

```sh
sudo systemctl restart gse-web
```

## Ce a vrut sÄƒ spunÄƒ autorul

Am fÄƒcut o aplicaÈ›ie web.
